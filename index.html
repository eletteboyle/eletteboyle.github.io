<html><head><title>
Elette Boyle </title>

<style>Body {

PADDING-RIGHT: 5px; PADDING-LEFT: 5px; PADDING-BOTTOM: 0px; MARGIN: 20px; FONT: 12px verdana, arial, helvetica, sans-serif; COLOR: #474747; PADDING-TOP: 0px; BACKGROUND-COLOR: #000000

}

A { TEXT-DECORATION: none }
A:link { COLOR: #bd00b0 }
A:visited { COLOR: #bd00bd }
A:hover { TEXT-DECORATION: underline }
H1 { COLOR: #909090 }

TD {
	FONT-SIZE: 12px; COLOR: #333; FONT-FAMILY: 12px verdana
}

.pageHeader {
	FONT-SIZE: 18px; COLOR: #000000; FONT-FAMILY: helvetica
}

H2 {
	PADDING-RIGHT: 0px; PADDING-LEFT: 0px; PADDING-BOTTOM: 0px; MARGIN: 10px 0px; FONT:
bold 12px/14px verdana, arial, helvetica, sans-serif; COLOR: #333; PADDING-TOP: 0px
}

DIV.Section1 {
	page: Section1
}


</style>


<script language="JavaScript" type="text/JavaScript"> 		function toggle(id) { 			
if (document.getElementById) 			{ 				if
(document.getElementById(id).style.display == "none") { 					// show 					
document.getElementById(id).style.display = "block"; 				} 				 else { 					 // hide 					 

document.getElementById(id).style.display = "none"; 				
} 			} 		} </script><style type="text/css"></style></head>

<body>


<table id="AutoNumber12" style="BORDER-COLLAPSE: collapse" bordercolor="#111111" height="103" cellspacing="0" cellpadding="0" width="100%" border="0">

  <tbody>

  <tr>

    <td valign="top" width="47%" height="103" rowspan="2">

        <img height="0" vspace="0">


      <h1><font face="Verdana" color="B0B0B0">Elette Boyle</font></h1>

<h2 style="MARGIN-LEFT: 0px"><span style="FONT-WEIGHT: 400"><font style="FONT-WEIGHT: 400; FONT-SIZE: 9pt" face="Verdana"><br>

<font color="808080">
eboyle [at] alum [dot] mit [dot] edu
<br><br>
</font>

<font color="B0B0B0">
<b>
As of Fall 2015, I am currently a Senior Lecturer (Assistant Professor) at IDC Herzliya in Israel.
</b>
</font>
<br><br>

<font color="707070">
I was recently a postdoctoral researcher at the Technion Israel Institute of Technology, hosted by <a href="http://www.cs.technion.ac.il/~yuvali/">Yuval Ishai</a>.
<br><br>


Previously, I was a Ph.D. student in the mathematics department at MIT, under the guidance of <a href="http://people.csail.mit.edu/shafi/">Shafi Goldwasser</a> (and <a href="http://research.microsoft.com/en-us/um/people/yael/">Yael Tauman Kalai</a>). Before MIT, I completed my undergraduate work in math at Caltech. 
<br><br>


Summer 2013 I was a short-term postdoc in cryptography at Cornell University (Cornell NYC Tech campus), hosted by <a href="http://www.cs.cornell.edu/~rafael/">Rafael Pass</a>. 

<br><br>


<font color="B0B0B0">
My research interests include cryptography, computer security, coding theory, algorithms, and other areas in the foundations of computer science. 
</font>
<br><br>


</font>
      </font></span></h2>

  </td><td valign="top" width="46%" height="79">

      <p align="center">
		<img border="0" title="EletteBoyle" alt="Elette Boyle" src="JapaneseBreakfast.jpg" width="373" height="285" align="right"></p></td></tr>

  <tr>

    <td width="46%" height="24">&nbsp;</td></tr></tbody></table>

<table height="187" cellspacing="1" cellpadding="8" width="100%" border="0">

  <tbody>
  
  
  
  
  



  
  
  


  <tr>

    <td valign="top" width="92" bgcolor="#B0B0B0">

      <h2><font color="#000000">Publications</font></h2></td>

    <td dir="ltr" align="left" bgcolor="#D0D0D0">

      <ul>





     <li><h2><span style="FONT-WEIGHT: 400"> Elette Boyle, Niv Gilboa, and Yuval Ishai </span><span style="font-weight: 400"><br> </span>
     Function Secret Sharing: Improvements and Extensions
<br><span style="FONT-WEIGHT: 400">
To appear: CCS 2016 - ACM Conference on Computer and Communications Security.</span>
<span style="FONT-WEIGHT: 400"><br> 		[<a href="javascript:toggle('abstract-BoyleGI16b')">Abstract</a>] 
</span></h2> 			 <div class="box" id="abstract-BoyleGI16b" style="border-style:solid; border-width:1px;
display: none; padding-left:4px; padding-right:4px; padding-top:1px;
padding-bottom:1px; background-color:#F0F0F0"> 			<h2><span style="font-weight:
400">
Function Secret Sharing (FSS), introduced by Boyle et al. (Eurocrypt 2015), provides a way for additively secret-sharing a function from a given function family F. More concretely, an m-party FSS scheme splits a function $f : {0,1}^n \to G, for some abelian group G, into functions f_1,...,f_m, described by keys k_1,...,k_m, such that f = f_1 + ... + f_m and every strict subset of the keys hides f. A Distributed Point Function (DPF) is a special case where F is the family of point functions, namely functions f_{a,b} that evaluate to b on the input a and to 0 on all other inputs.
<br><br>
FSS schemes are useful for applications that involve privately reading from or writing to distributed databases while minimizing the amount of communication. These include different flavors of private information retrieval (PIR), as well as a recent application of DPF for large-scale anonymous messaging.
<br><br>
We improve and extend previous results in several ways:
<br>
1. Simplified FSS constructions. We introduce a tensoring operation for FSS which is used to obtain a conceptually simpler derivation of previous constructions and present our new constructions.
<br>
2. Improved 2-party DPF. We reduce the key size of the PRG-based DPF scheme of Boyle et al. roughly by a factor of 4 and optimize its computational cost. The optimized DPF significantly improves the concrete costs of 2-server PIR and related primitives.
<br>
3. FSS for new function families. We present an efficient PRG-based 2-party FSS scheme for the family of decision trees, leaking only the topology of the tree and the internal node labels. We apply this towards FSS for multi-dimensional intervals. We also present a general technique for extending FSS schemes by in- creasing the number of parties.
<br>
4. Verifiable FSS. We present efficient protocols for verifying that keys (k_1,...,k_m), obtained from a potentially malicious user, are consistent with some f \in F. Such a verification may be critical for applications that involve private writing or voting by many users.
</span></h2> </div>





     <li><h2><span style="FONT-WEIGHT: 400"> Elette Boyle, Niv Gilboa, and Yuval Ishai </span><span style="font-weight: 400"><br> </span>
     Breaking the Circuit-Size Barrier for Secure Computation Under DDH
<br><span style="FONT-WEIGHT: 400">
CRYPTO 2016 - International Conference on Cryptology.</span>
<br>
<b><i>Best Paper Award.</i></b>
<span style="FONT-WEIGHT: 400"><br> 		[<a href="javascript:toggle('abstract-BoyleGI16')">Abstract</a>] 		[<a href="http://eprint.iacr.org/2016/585.pdf">PDF</a>]
</span></h2> 			 <div class="box" id="abstract-BoyleGI16" style="border-style:solid; border-width:1px;
display: none; padding-left:4px; padding-right:4px; padding-top:1px;
padding-bottom:1px; background-color:#F0F0F0"> 			<h2><span style="font-weight:
400">
Under the Decisional Diffie-Hellman (DDH) assumption, we present a 2-out-of-2 secret sharing scheme that supports a compact evaluation of branching programs on the shares. More concretely, there is an evaluation algorithm \Eval with a single bit of output, such that if an input $w \in {0,1}^n$ is shared into $(w^0,w^1)$, then for any deterministic branching program P of size S we have that \Eval(P,w0) \xor \Eval(P,w1)=P(w), except with at most \delta failure probability. The running time of the sharing algorithm is polynomial in n and the security parameter \lambda, and that of \Eval is polynomial in S, \lambda, and 1/\delta. This applies as a special case to boolean formulas of size S or boolean circuits of depth log S. We also present a public-key variant that enables homomorphic computation on inputs contributed by multiple clients. The above result implies the following DDH-based applications:

<br><br>
- A secure 2-party computation protocol for evaluating any branching program of size S, where the communication complexity is linear in the input size and only the running time grows with S.

<br><br>
- A secure 2-party computation protocol for evaluating any layered boolean circuit of size S and m outputs with communication complexity O(S/logS)+m*poly(\lambda).

<br><br>
-A 2-party {\em function secret sharing} scheme, as defined by Boyle et al. (Eurocrypt 2015), for general branching programs (with inverse polynomial error probability).

<br><br>
- A 1-round 2-server {\em private information retrieval} scheme supporting general searches expressed by branching programs.
</span></h2> </div>




     <li><h2><span style="FONT-WEIGHT: 400"> Elette Boyle and Moni Naor </span><span style="font-weight: 400"><br> </span>Is There an Oblivious RAM Lower Bound?
<br><span style="FONT-WEIGHT: 400">ITCS 2016 - Innovations in Theoretical Computer Science.</span>
<span style="FONT-WEIGHT: 400"><br> 		[<a href="javascript:toggle('abstract-ORAM-LB')">Abstract</a>] 		[<a href="http://eccc.hpi-web.de/report/2015/146/">PDF</a>]
</span></h2> 			 <div class="box" id="abstract-ORAM-LB" style="border-style:solid; border-width:1px;
display: none; padding-left:4px; padding-right:4px; padding-top:1px;
padding-bottom:1px; background-color:#F0F0F0"> 			<h2><span style="font-weight:
400">
An Oblivious RAM (ORAM), introduced by Goldreich and Ostrovsky (JACM 1996), is a (probabilistic) RAM that hides its access pattern, i.e. for every input the observed locations accessed are similarly distributed. Great progress has been made in recent years in minimizing the overhead of ORAM constructions, with the goal of obtaining the smallest overhead possible.

<br><br>
We revisit the lower bound on the overhead required to obliviously simulate programs, due to Goldreich and Ostrovsky. While the lower bound is fairly general, including the offline case, when the simulator is given the reads and writes ahead of time, it does assume that the simulator behaves in a ?balls and bins? fashion. That is, the simulator must act by shuffling data items around, and is not allowed to have sophisticated encoding of the data.

<br><br>
We prove that for the offline case, showing a lower bound without the above restriction is related to the size of the circuits for sorting. Our proof is constructive, and uses a bit-slicing approach which manipulates the bit representations of data in the simulation. This implies that without obtaining yet unknown superlinear lower bounds on the size of such circuits, we cannot hope to get lower bounds on offline (unrestricted) ORAMs.
</span></h2> </div>



		</li><li><h2><span style="FONT-WEIGHT: 400"> Elette Boyle,
	  Kai-Min Chung, and Rafael Pass</span><span style="font-weight: 400"><br> </span>Oblivious Parallel RAM
<br><span style="FONT-WEIGHT: 400">TCC 2016 - Theory of Cryptography Conference.</span>
<span style="FONT-WEIGHT: 400"><br> 		[<a href="javascript:toggle('abstract-OPRAM')">Abstract</a>] 		[<a href="http://eprint.iacr.org/2014/594">PDF</a>]
</span></h2> 			 <div class="box" id="abstract-OPRAM" style="border-style:solid; border-width:1px;
display: none; padding-left:4px; padding-right:4px; padding-top:1px;
padding-bottom:1px; background-color:#F0F0F0"> 			<h2><span style="font-weight:
400">
A machine is said to be {\em oblivious} if the sequences of memory accesses made by the machine for two inputs of the same running time are identically (or close to identically) distributed. Oblivious RAM (ORAM) compilers -- compilers that turn any RAM program $\Pi$ into an oblivious RAM $\Pi'$, while only incurring a "small", polylogarithmic slowdown -- have been extensively studied since the work of Goldreich and Ostrovsky (J.ACM'96) and have numerous fundamental applications. These compilers, however, do not level parallelism: even if $\Pi$ can be highly parallelized, $\Pi'$ will be inherently sequential.
<br><br>
In this work we present the first {\em Oblivious Parallel RAM (OPRAM)} compiler, which compiles any PRAM into an oblivious PRAM while only incurring a polylogarithmic slowdown.

</span></h2> </div>



     </li><li><h2><span style="FONT-WEIGHT: 400"> Elette Boyle, Niv Gilboa, Yuval Ishai </span><span style="font-weight: 400"><br> </span>Function Secret Sharing
<br><span style="FONT-WEIGHT: 400">Advances in Cryptology - EUROCRYPT 2015.</span><span style="FONT-WEIGHT: 400"><br> 		[<a href="javascript:toggle('abstract-FSS')">Abstract</a>] 		[<a href="http://link.springer.com/chapter/10.1007%2F978-3-662-46803-6_12">PDF</a>]
</span></h2> 			 <div class="box" id="abstract-FSS" style="border-style:solid; border-width:1px;
display: none; padding-left:4px; padding-right:4px; padding-top:1px;
padding-bottom:1px; background-color:#F0F0F0"> 			<h2><span style="font-weight:
400">
Motivated by the goal of securely searching and pdating distributed data, we introduce and study the notion of function secret sharing (FSS). This new notion is a natural generalization of distributed point functions (DPF), a primitive that was recently introduced by Gilboa and Ishai (Eurocrypt 2014). Given a positive integer $p \ge 2$ and a class $\mathcal{F}$ of functions $f: \{0,1\}^n \to \mathbb{G}$ where $\mathbb{G}$ is an Abelian group, a $p$-party FSS scheme for $\mathcal{F}$ allows one to split each $f \in \mathcal{F}$ into $p$ succinctly described functions $f_i: \{0,1\}^n \to \mathbb{G}$, $1 \le i \le p$, such that: (1) $\sum_{i1=}^p f_i = f$, and (2) any strict subset of the $f_i$ hides $f$. Thus, an FSS for $\mathcal{F}$ can be thought of as a method for succinctly performing an "additive secret sharing" of functions from $\mathcal{F}$.The original definition of DPF coincides with a two-party FSS for the class of point functions, namely the class of functions that have a nonzero output on at most one input.

<br><br>

We present two types of results. First, we obtain efficiency improvements and extensions of the original DPF construction. Then, we initiate a systematic study of general FSS, providing some constructions and establishing relations with other cryptographic primitives. More concretely, we obtain the following main results:

<br><br>
1. Improved DPF. We present an improved (two-party) DPF construction from a pseudorandom generator (PRG), reducing the length of the key describing each $f_i$ from $O(\lambda \cdot n^{\log_2(3)})$ to $O(\lambda n)$, where $\lambda$ is the PRG seed length.

<br><br>
2. Multi-party DPF. We present the first nontrivial construction of a $p$-party DPF for $p \ge 3$, obtaining a near-quadratic improvement over a naive construction that additively shares the truth-table of $f$. This construction too can be based on any PRG.

<br><br>
3. FSS for simple functions. We present efficient PRG-based FSS constructions for natural function classes that extend point functions, including interval functions and partial matching functions.

<br><br>
4. A study of general FSS. We show several relations between general FSS and other cryptographic primitives. These include a construction of general FSS via obfuscation, an indication for the implausibility of constructing general FSS from weak cryptographic assumptions such as the existence of one-way functions, a completeness result, and a relation with pseudorandom functions.

</span></h2> </div>



     

		</li><li><h2><span style="FONT-WEIGHT: 400"> Elette Boyle,
	 Kai-Min Chung, and Rafael Pass</span><span style="font-weight: 400"><br> </span>Large-Scale Secure Computation
<br><span style="FONT-WEIGHT: 400">CRYPTO 2015 - International Conference on Cryptology.</span><span style="FONT-WEIGHT: 400"><br> 		[<a href="javascript:toggle('abstract-largeMPC')">Abstract</a>] 		[<a href="http://eprint.iacr.org/2014/404">PDF</a>]
</span></h2> 			 <div class="box" id="abstract-largeMPC" style="border-style:solid; border-width:1px;
display: none; padding-left:4px; padding-right:4px; padding-top:1px;
padding-bottom:1px; background-color:#F0F0F0"> 			<h2><span style="font-weight:
400">
We are interested in secure computation protocols in settings where the number of parties is huge and their data even larger. Assuming the existence of a single-use broadcast channel (per player), we demonstrate statistically secure computation protocols for computing (multiple) arbitrary dynamic RAM programs over parties' inputs, handling (1/3-eps) fraction static corruptions, while preserving up to polylogarithmic factors the computation and memory complexities of the RAM program. Additionally, our protocol is load balanced and has polylogarithmic communication locality.
</span></h2></div>


		</li><li><h2><span style="FONT-WEIGHT: 400"> Elette Boyle
	 and Rafael Pass</span><span style="font-weight: 400"><br> </span>Limits of Extractability Assumptions with Distributional Auxiliary Input 
<br><span style="FONT-WEIGHT: 400">Asiacrypt 2015 - International Conference on the Theory and Applications of Cryptology and Information Security.</span><span style="FONT-WEIGHT: 400"><br> 		[<a href="javascript:toggle('abstract-ext-assmpt')">Abstract</a>] 		[<a href="http://eprint.iacr.org/2013/703.pdf">PDF</a>]
</span></h2> 			 <div class="box" id="abstract-ext-assmpt" style="border-style:solid; border-width:1px;
display: none; padding-left:4px; padding-right:4px; padding-top:1px;
padding-bottom:1px; background-color:#F0F0F0"> 			<h2><span style="font-weight:
400">
Extractability, or "knowledge," assumptions (such as the "knowledge-of-exponent" assumption) have recently gained popularity in the cryptographic community—leading to the study of primitives such as extractable one-way functions, extractable hash functions, succinct non-interactive arguments of knowledge (SNARKs), and extractable obfuscation, and spurring the development of a wide spectrum of new applications relying on these primitives. For most of these applications, it is required that the extractability assumption holds even in the presence of attackers receiving some auxiliary information that is sampled from some fixed efficiently computable distribution Z.
<br><br>
We show that, assuming the existence of collision-resistant hash functions, there exists a pair of efficient distributions Z, Z'; such that either:
<ul>
<li> extractable one-way functions w.r.t. Z do not exist, or </li>
<li> extractability obfuscations for Turing machines w.r.t. Z do not exist. </li>
</ul>
<br><br> 

A corollary of this result shows that assuming existence of fully homomorphic encryption with decryption in NC1, there exist efficient distributions Z, Z' such that either
<ul>
<li> extractability obfuscations for NC1 w.r.t. Z do not exist, or </li>
<li> SNARKs for NP w.r.t. Z' do not exist. </li>
</ul>
<br><br> 

To achieve our results, we develop a "succinct punctured program" technique, mirroring the powerful "punctured program" technique of Sahai and Waters (ePrint'13), and present several other applications of this new technique.
</span></h2> </div>






		</li><li><h2><span style="FONT-WEIGHT: 400"> Elette Boyle,
	 Kai-Min Chung, and Rafael Pass</span><span style="font-weight: 400"><br> </span>
On Extractability (a.k.a. Differing-Inputs) Obfuscation
<br><span style="FONT-WEIGHT: 400">TCC 2014 - Theory of Cryptography Conference.</span><span style="FONT-WEIGHT: 400"><br> 		[<a href="javascript:toggle('abstract-eO')">Abstract</a>] 		[<a href="http://eprint.iacr.org/2013/650.pdf">PDF</a>]
</span></h2> 			 <div class="box" id="abstract-eO" style="border-style:solid; border-width:1px;
display: none; padding-left:4px; padding-right:4px; padding-top:1px;
padding-bottom:1px; background-color:#F0F0F0"> 			<h2><span style="font-weight:
400">
We initiate the study of <i>extractability obfuscation</i>, a notion first suggested by Barak et al. (JACM 2012): An extractability obfuscator eO for a class of algorithms M guarantees that if an efficient attacker A can distinguish between obfuscations eO(M_1), eO(M_2) of two algorithms M_1,M_2 \in M, then A can efficiently recover (given M_1 and M_2) an input on which M_1 and M_2 provide different outputs.

<ul>
<li>We rely on the recent candidate virtual black-box obfuscation constructions to provide candidate constructions of extractability obfuscators for NC^1; next, following the blueprint of Garg et~al. (FOCS 2013), we show how to bootstrap the obfuscator for NC^1 to an obfuscator for all non-uniform polynomial-time Turing machines. In contrast to the construction of Garg et al., which relies on indistinguishability obfuscation for NC^1, our construction enables succinctly obfuscating non-uniform <i>Turing machines</i> (as opposed to circuits), without turning running-time into description size.
</li>
<li>We introduce a new notion of <i>functional witness encryption</i>, which enables encrypting a message m with respect to an instance x, language L, and function f, such that anyone (and only those) who holds a witness w for x \in L can compute f(m,w) on the message and particular known witness. We show that functional witness encryption is, in fact, equivalent to extractability obfuscation.
</li>
<li> We demonstrate other applications of extractability extraction, including the first construction of fully (adaptive-message) indistinguishability-secure functional encryption for an unbounded number of key queries and unbounded message spaces.
</li>
<li> We finally relate indistinguishability obfuscation and extractability obfuscation and show special cases when indistinguishability obfuscation can be turned into extractability obfuscation.
</li>
</ul>
</span></h2> </div>






		</li><li><h2><span style="FONT-WEIGHT: 400"> Elette Boyle,
	  Shafi Goldwasser, and Ioana Ivan</span><span style="font-weight: 400"><br> </span>
Functional Signatures and Pseudorandom Functions
<br><span style="FONT-WEIGHT: 400">PKC 2014 - International Conference on Practice and Theory of Public-Key Cryptography.</span><span style="FONT-WEIGHT: 400"><br> 		[<a href="javascript:toggle('abstract-fnalSigs')">Abstract</a>] 		[<a href="http://eprint.iacr.org/2013/401.pdf">PDF</a>]
</span></h2> 			 <div class="box" id="abstract-fnalSigs" style="border-style:solid; border-width:1px;
display: none; padding-left:4px; padding-right:4px; padding-top:1px;
padding-bottom:1px; background-color:#F0F0F0"> 			<h2><span style="font-weight:
400">
In this paper, we introduce two new cryptographic primitives: <i>functional digital signatures</i> and <i>functional pseudorandom functions</i>.
<br><br>

In a functional signature scheme, in addition to a master signing key that can be used to sign any message, there are <i>signing keys for a function</i> f, which allow one to sign any message in the range of f. As a special case, this implies the ability to generate keys for predicates P, which allow one to sign any message m, for which P(m) = 1.
<br><br>

We show applications of functional signatures to constructing succinct non-interactive arguments and delegation schemes. We give several general constructions for this primitive based on different computational hardness assumptions, and describe the trade-offs between them in terms of the assumptions they require and the size of the signatures.
<br><br>

In a functional pseudorandom function, in addition to a master secret key that can be used to evaluate the pseudorandom function F on any point in the domain, there are additional <i>secret keys for a function</i> f, which allow one to evaluate F on any y for which there exists an x such that f(x)=y. As a special case, this implies <i>pseudorandom functions with selective access</i>, where one can delegate the ability to evaluate the pseudorandom function on inputs y for which a predicate P(y)=1 holds. We define and provide a sample construction of a functional pseudorandom function family for prefix-fixing functions.
</span></h2> </div>




		</li><li><h2><span style="FONT-WEIGHT: 400"> Elette Boyle,
	  Sanjam Garg, Abhishek Jain, Yael Tauman Kalai, and Amit Sahai
	 </span><span style="font-weight: 400"><br> </span>
Secure Computation Against Adaptive Auxiliary Information
<br><span style="FONT-WEIGHT: 400">CRYPTO 2013 - International Conference on Cryptology.</span><span style="FONT-WEIGHT: 400"><br> 		[<a href="javascript:toggle('abstract-WLR-MPC')">Abstract</a>] 		[<a href="http://link.springer.com/chapter/10.1007%2F978-3-642-40041-4_18">PDF</a>]
</span></h2> 			 <div class="box" id="abstract-WLR-MPC" style="border-style:solid; border-width:1px;
display: none; padding-left:4px; padding-right:4px; padding-top:1px;
padding-bottom:1px; background-color:#F0F0F0"> 			<h2><span style="font-weight:
400">
We study the problem of secure two-party and multiparty computation (MPC) in a setting where a cheating polynomial-time adversary can corrupt an arbitrary subset of parties and, in addition, learn arbitrary auxiliary information on the entire states of all honest parties (including their inputs and random coins), in an adaptive manner, throughout the protocol execution. We formalize a definition of multiparty computation secure against adaptive auxiliary information (AAI-MPC), that intuitively guarantees that such an adversary learns no more than the function output and the adaptive auxiliary information. In particular, if the auxiliary information contains only partial, "noisy," or computationally invertible information on secret inputs, then only such information should be revealed.
<br><br> 

We construct a universally composable AAI two-party and multiparty computation protocol that realizes any (efficiently computable) functionality against malicious adversaries in the common reference string model, based on the linear assumption over bilinear groups and the <i>n</i>-th residuosity assumption. Apart from theoretical interest, our result has interesting applications to the regime of leakage-resilient cryptography.
<br><br>

At the heart of our construction is a new two-round oblivious transfer protocol secure against malicious adversaries who may receive adaptive auxiliary information. This may be of independent interest.
</span></h2> </div>




		</li><li><h2><span style="FONT-WEIGHT: 400"> Elette Boyle,
	Shafi Goldwasser, and Stefano Tessaro
	 </span><span style="font-weight: 400"><br> </span>
Communication Locality in Secure Multi-party Computation: 
<br>How to Run Sublinear Algorithms in a Distributed Setting
<br><span style="FONT-WEIGHT: 400">TCC 2013 - Theory of Cryptography Conference.</span><span style="FONT-WEIGHT: 400"><br> 		[<a href="javascript:toggle('abstract-sl-mpc')">Abstract</a>] 		[<a href="MPC-Locality-TCC13.pdf">PDF</a>]
</span></h2> 			 <div class="box" id="abstract-sl-mpc" style="border-style:solid; border-width:1px;
display: none; padding-left:4px; padding-right:4px; padding-top:1px;
padding-bottom:1px; background-color:#F0F0F0"> 			<h2><span style="font-weight:
400">
We devise multi-party computation protocols for general secure function evaluation with the property that each party is only required to communicate with a small number of dynamically chosen parties. More explicitly, starting with n parties connected via a complete and synchronous network, our protocol requires each party to send messages to (and process messages from) at most polylog(n) other parties using polylog(n) rounds. It achieves secure computation of any polynomial-time computable randomized function f under cryptographic
assumptions, and tolerates up to (1/3 - \eps)n statically scheduled Byzantine faults.
<br><br>

We then focus on the particularly interesting setting in which the function to be computed is a sublinear algorithm: An evaluation of f depends on the inputs of at most q = o(n) of the parties, where the identity of these parties can be chosen randomly and possibly adaptively. Typically, q = polylog(n). While the sublinear query complexity of f makes it pos- sible in principle to dramatically reduce the communication complexity of our general protocol, the challenge is to achieve this while maintaining security: in particular, while keeping the identities of the selected inputs completely hidden. We solve this challenge, and we provide a protocol for securely computing such sublinear f that runs in polylog(n) + O(q) rounds, has each party communicating with at most q*polylog(n) other parties, and supports message sizes polylog(n) (l + n), where l is the parties' input size.
<br><br>

Our optimized protocols rely on a multi-signature scheme, fully homomorphic encryption (FHE), and simulation-sound adaptive NIZK arguments. However, we remark that multi-signatures and FHE are used to obtain our bounds on message size and round complexity. Assuming only standard digital signatures and public-key encryption, one can still obtain the property that each party only communicates with polylog(n) other parties. We emphasize that the scheduling of faults can depend on the initial PKI setup of digital signatures and the NIZK parameters
</span></h2> </div>




		</li><li><h2><span style="FONT-WEIGHT: 400"> Elette Boyle,
	Shafi Goldwasser, Abhishek Jain, and Yael Tauman Kalai
	 </span><span style="font-weight: 400"><br> </span>
Multi-Party Computation Secure Against Continual Memory Leakage
<br><span style="FONT-WEIGHT: 400">STOC 2012 - ACM Symposium on Theory of Computing.</span><span style="FONT-WEIGHT: 400"><br> 		[<a href="javascript:toggle('abstract-LR-MPC')">Abstract</a>] 		[<a href="LR-MPC-STOC12.pdf">PDF</a>]
</span></h2> 			 <div class="box" id="abstract-LR-MPC" style="border-style:solid; border-width:1px;
display: none; padding-left:4px; padding-right:4px; padding-top:1px;
padding-bottom:1px; background-color:#F0F0F0"> 			<h2><span style="font-weight:
400">
We construct a multiparty computation (MPC) protocol that is secure even if a malicious adversary, in addition to corrupting 1-\eps fraction of all parties for an arbitrarily small constant \eps &gt; 0, can leak information about the secret state of each honest party. This leakage can be continuous for an unbounded number of executions of the MPC protocol, computing different functions on the same or different set of inputs. We assume a (necessary) "leak-free" preprocessing stage.
<br><br>

We emphasize that we achieve leakage resilience without weakening the security guarantee of classical MPC. Namely, an adversary who is given leakage on honest parties' states, is guaranteed to learn nothing beyond the input and output values of corrupted parties. This is in contrast with previous works on leakage in the multi-party protocol setting, which weaken the security notion, and only guarantee that a protocol which leaks l bits about the parties' secret states, yields at most l bits of leakage on the parties' private inputs. For some functions, such as voting, such leakage can be detrimental.
<br><br>

Our result relies on standard cryptographic assumptions, and our security parameter is polynomially related to the number of parties.
</span></h2> </div>





		</li><li><h2><span style="FONT-WEIGHT: 400"> Elette Boyle,
	Shafi Goldwasser, and Yael Tauman Kalai
	 </span><span style="font-weight: 400"><br> </span>
Leakage-Resilient Coin Tossing
<br><span style="FONT-WEIGHT: 400">DISC 2011 - The International Symposium on Distributed Computing.
	<br> <i>Invited to Distributed Computing.</i></span><span style="FONT-WEIGHT: 400"><br> 		[<a href="javascript:toggle('abstract-LR-coin')">Abstract</a>] 		[<a href="http://eprint.iacr.org/2011/291">PDF</a>]
</span></h2> 			 <div class="box" id="abstract-LR-coin" style="border-style:solid; border-width:1px;
display: none; padding-left:4px; padding-right:4px; padding-top:1px;
padding-bottom:1px; background-color:#F0F0F0"> 			<h2><span style="font-weight:
400">
The ability to collectively toss a common coin among n parties in the presence of faults is an important primitive in the arsenal of randomized distributed protocols. In the case of dishonest majority, it was shown to be impossible to achieve less than 1/r bias in O(r) rounds (Cleve STOC '86). In the case of honest majority, in contrast, unconditionally secure O(1)-round protocols for generating common perfectly <i>unbiased</i> coins follow from general completeness theorems on multi-party secure protocols in the perfectly secure channels model (e.g., BGW, CCD STOC '88).
<br><br>

However, in the multi-party protocols with faulty minority, parties need to generate and hold local secret values which are assumed to be <i>perfectly hidden</i> from malicious parties: an assumption which is crucial to proving the resulting common coin is unbiased. This assumption unfortunately does not seem to hold in practice, as attackers can launch side-channel attacks on the local state of honest parties and leak information on their secrets.
<br><br>

In this work, we present an O(1)-round protocol for collectively generating an unbiased common coin, in the presence of leakage on the local state of the honest parties. We tolerate t &lt;= (1/3 - \eps) n computationally-unbounded Byzantine faults and in addition a \Omega(1)-fraction leakage on each (honest) party's secret state. Our results hold in the memory leakage model (of Akavia, Goldwasser, Vaikuntanathan '08) adapted to the distributed setting.
<br><br>

Another contribution of our work is a tool we use to achieve collective coin flipping -- <i>leakage-resilient verifiable secret sharing</i>. Informally, this is a variant of ordinary VSS in which secrecy guarantees are maintained even if information is leaked on individual shares of the secret.

</span></h2> </div>





</li><li><h2><span style="FONT-WEIGHT: 400"> Elette Boyle,
	Gil Segev, and Daniel Wichs
	 </span><span style="font-weight: 400"><br> </span>
Fully Leakage-Resilient Signatures
<br><span style="FONT-WEIGHT: 400">Advances in Cryptology - EUROCRYPT 2011.
	<br> <i>Invited to Journal of Cryptology.</i></span><span style="FONT-WEIGHT: 400"><br> 		[<a href="javascript:toggle('abstract-FLR-sig')">Abstract</a>] 		[<a href="http://eprint.iacr.org/2010/488">PDF</a>]
</span></h2> 			 <div class="box" id="abstract-FLR-sig" style="border-style:solid; border-width:1px;
display: none; padding-left:4px; padding-right:4px; padding-top:1px;
padding-bottom:1px; background-color:#F0F0F0"> 			<h2><span style="font-weight:
400">
A signature scheme is <i>fully leakage resilient</i> (Katz and Vaikuntanathan, ASIACRYPT '09) if it is existentially unforgeable under an adaptive chosen-message attack even in a setting where an adversary may obtain bounded (yet arbitrary) leakage information on <i>all intermediate values that are used throughout the lifetime of the system</i>. This is a strong and meaningful notion of security that captures a significantly wide range of side-channel attacks.
<br><br>

One of the main challenges in constructing fully leakage-resilient signature schemes is dealing with leakage that may depend on the random bits used by the signing algorithm, and constructions of such schemes are known only in the random-oracle model. Moreover, even in the random-oracle model, known schemes are only resilient to leakage of less than half the length of their signing key.
<br><br>

In this paper we construct the first fully leakage-resilient signature schemes without random oracles. We present a scheme that is resilient to any leakage of length (1-o(1))L bits, where L is the length of the signing key. Our approach relies on generic cryptographic primitives, and at the same time admits rather efficient instantiations based on specific number-theoretic assumptions. In addition, we show that our approach extends to the continual-leakage model, recently introduced by Dodis, Haralambiev, Lopez-Alt and Wichs (FOCS '10), and by Brakerski, Tauman Kalai, Katz and Vaikuntanathan (FOCS '10). In this model the signing key is allowed to be refreshed, while its corresponding verification key remains fixed, and the amount of leakage is assumed to be bounded only in between any two successive key refreshes.
</span></h2> </div>





</li><li><h2><span style="FONT-WEIGHT: 400"> Elette Boyle
	and Federico Echenique
	 </span><span style="font-weight: 400"><br> </span>
Sequential Entry in Many-to-One Matching Markets
<br><span style="FONT-WEIGHT: 400">Social Choice and Welfare, Springer, Vol 33(1), June 2009: pp 87-99. </span><span style="FONT-WEIGHT: 400"><br> 		[<a href="javascript:toggle('abstract-matching')">Abstract</a>] 		[<a href="Sequential-Entry-SCW09.pdf">PDF</a>]
</span></h2> 			 <div class="box" id="abstract-matching" style="border-style:solid; border-width:1px;
display: none; padding-left:4px; padding-right:4px; padding-top:1px;
padding-bottom:1px; background-color:#F0F0F0"> 			<h2><span style="font-weight:
400">
We study sequential bargaining in many-to-one matching markets. We show that there is an advantage to entering late in the market, and that the last agent to enter the market will receive his or her best partner in a stable matching, extending the results of Blum and Rothblum (J Econ Theory 103(2):429-443, 2002) and Cechlárová (Randomized matching mechanism revisited. Mimeo, Safarik University, 2002) for the marriage model. We also discuss the relation between sequential bargaining and a possible alternative formulation based on the NTU Shapley value.
</span></h2> </div>





</li><li><h2><span style="FONT-WEIGHT: 400"> Elette Boyle
	and Robert McEliece
	 </span><span style="font-weight: 400"><br> </span>
Asymptotic Weight Enumerators of Randomly Punctured, Expurgated, and Shortened Code Ensembles 
<br><span style="FONT-WEIGHT: 400">46th Annual Allerton Conference on Communication, Control, and Computing, 2008. </span><span style="FONT-WEIGHT: 400"><br> 		[<a href="javascript:toggle('abstract-codes')">Abstract</a>] 		[<a href="Altered-Codes-Allerton08.pdf">PDF</a>]
</span></h2> 			 <div class="box" id="abstract-codes" style="border-style:solid; border-width:1px;
display: none; padding-left:4px; padding-right:4px; padding-top:1px;
padding-bottom:1px; background-color:#F0F0F0"> 			<h2><span style="font-weight:
400">
In this paper, we examine the effect of random puncturing, expurgating, and shortening on the asymptotic weight enumerator of certain linear code ensembles. We begin by discussing the actions of the three alteration methods on individual codes. We derive expressions for the average resulting code weight enumerator under each alteration. We then extend these results to the spectral shape of linear code ensembles whose original spectral shape is known, and demonstrate our findings on two specific code ensembles: the Shannon ensemble and the regular (j, k) Gallager ensemble.
</span></h2> </div>


</li><li><h2><span style="FONT-WEIGHT: 400"> Elette Boyle
	 </span><span style="font-weight: 400"><br> </span>
Navigation on Mars: Validation of the Mars Science Laboratory Rover Hazard Avoidance Algorithm
<br><span style="FONT-WEIGHT: 400">Caltech Undergraduate Research Journal Vol 5, 2006: pp 21-25. </span><span style="FONT-WEIGHT: 400"><br> 		
[<a href="javascript:toggle('abstract-MSL')">Abstract</a>] 

</span></h2> 			 <div class="box" id="abstract-MSL" style="border-style:solid; border-width:1px;
display: none; padding-left:4px; padding-right:4px; padding-top:1px;
padding-bottom:1px; background-color:#F0F0F0"> 			<h2><span style="font-weight:
400">
The Mars Science Laboratory (MSL) is a long-range, long-duration
roving laboratory planned for launch in 2009. While humans can issue commands to the rover on Mars, the delay in transmission means navigation functions requiring immediate action, such as recognizing hazards and locating pathways of safety, must be controlled autonomously. The autonomous navigation software currently used in Mars rovers is designed for use in terrains with minimal inclines and few obstacles. However, for MSL, NASA is developing a more advanced version of the Mars Exploration Rover (MER) GESTALT hazard detection and avoidance software. Ensuring that GESTALT functions correctly and effectively is a crucial task, since a malfunction could result in failure of the entire mission. Before use on Mars, GESTALT performance must be verified in a cross-section of potential terrains, including regions with rocks, craters, and slopes. The purpose of the summer research project was to test GESTALT in terrains of a range of rock hazard densities.
</span></h2> </div>



</li></ul></td></tr>













 <tr>

    <td valign="top" width="92" bgcolor="#A0A0A0">

      <h2><font color="#000000">Program Committees</font></h2></td>

    <td dir="ltr" align="left" bgcolor="#D0D0D0">

	<ul> <li>CRYPTO 2017 - International Conference on Cryptology.</li></ul>
	<ul> <li>Innovations in Theoretical Computer Science (ITCS) 2017.</li></ul>
	<ul> <li>Theory of Cryptography Conference (TCC) 2016B.</li></ul>
	<ul> <li>EUROCRYPT 2016.</li></ul>
	<ul> <li>Theory of Cryptography Conference (TCC) 2015.</li> </ul>
 	<ul> <li>Conference on Security and Cryptography for Networks (SCN) 2014.</li> </ul>
   </td></tr>
   
   
   
   
   
     <tr>

    <td valign="top" width="92" bgcolor="#A0A0A0">

      <h2><font color="#000000">Internships and Visits</font></h2></td>

    <td dir="ltr" align="left" bgcolor="#D0D0D0">

	<ul>

<li><h2><span style="font-weight: 400"></span>Microsoft Research Silicon Valley
<br>
<span style="FONT-WEIGHT: 400">Research Internship, Summer 2011  </span></h2></li>

<li><h2><span style="font-weight: 400"></span>Weizmann Institute of Science
<br>
<span style="FONT-WEIGHT: 400">Visiting Student, Spring and Summer 2010  </span></h2></li>

<li><h2><span style="font-weight: 400"></span>US Department of Defense 
<br>
<span style="FONT-WEIGHT: 400">Research Internship, Director's Summer Program, Summer 2007   </span></h2></li>


<li><h2><span style="font-weight: 400"></span>NASA Jet Propulsion Laboratory 
<br>
<span style="FONT-WEIGHT: 400">Research Internship, Robotic Software Systems Group, Summer 2005
<br>
Mars Science Laboratory (Curiosity Rover) Mission.   </span></h2></li>

	  </ul>
   </td></tr>

   
   
   
   </tbody></table>














</body></html>