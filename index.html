<HTML><HEAD>
<TITLE>
Elette Boyle </TITLE>

<STYLE>Body {

PADDING-RIGHT: 5px; PADDING-LEFT: 5px; PADDING-BOTTOM: 0px; MARGIN: 20px; FONT: 12px verdana, arial, helvetica, sans-serif; COLOR: #474747; PADDING-TOP: 0px; BACKGROUND-COLOR: #000000

}

A { TEXT-DECORATION: none }
A:link { COLOR: #bd00b0 }
A:visited { COLOR: #bd00bd }
A:hover { TEXT-DECORATION: underline }
H1 { COLOR: #909090 }

TD {
	FONT-SIZE: 12px; COLOR: #333; FONT-FAMILY: 12px verdana
}

.pageHeader {
	FONT-SIZE: 18px; COLOR: #000000; FONT-FAMILY: helvetica
}

H2 {
	PADDING-RIGHT: 0px; PADDING-LEFT: 0px; PADDING-BOTTOM: 0px; MARGIN: 10px 0px; FONT:
bold 12px/14px verdana, arial, helvetica, sans-serif; COLOR: #333; PADDING-TOP: 0px
}

DIV.Section1 {
	page: Section1
}


</STYLE>


<script language="JavaScript" type="text/JavaScript"> 		function toggle(id) { 			
if (document.getElementById) 			{ 				if
(document.getElementById(id).style.display == "none") { 					// show 					
document.getElementById(id).style.display = "block"; 				} 				 else { 					 // hide 					 

document.getElementById(id).style.display = "none"; 				
} 			} 		} </script></HEAD>

<BODY>


<TABLE id=AutoNumber12 style="BORDER-COLLAPSE: collapse" borderColor=#111111

height=103 cellSpacing=0 cellPadding=0 width="100%" border=0>

  <TBODY>

  <TR>

    <TD vAlign=top width="47%" height=103 rowSpan=2>

        <img height="0" vspace="0">


      <H1><FONT face=Verdana color=C0C0C0>Elette Boyle</FONT></H1>

<H2 style="MARGIN-LEFT: 0px"><SPAN style="FONT-WEIGHT: 400"><FONT
style="FONT-WEIGHT: 400; FONT-SIZE: 9pt" face=Verdana><BR>

<font color=808080>
eboyle [at] alum [dot] mit [dot] edu
<br/><br/>
</font>

<font color=707070>
I am currently a postdoctoral researcher at the Technion Israel Institute of Technology, hosted by <a href="http://www.cs.technion.ac.il/~yuvali/">Yuval Ishai</a>.
</br></br>

This summer I was a short-term postdoc in theoretical cryptography at Cornell NYC Tech, hosted by <a href="http://www.cs.cornell.edu/~rafael/">Rafael Pass</a>. 
</br></br> 

I was recently a Ph.D. student in the mathematics department at MIT, under the guidance of <a href="http://people.csail.mit.edu/shafi/">Shafi Goldwasser</a> and <a href="http://research.microsoft.com/en-us/um/people/yael/">Yael Tauman Kalai</a>. Before MIT, I completed my undergraduate work in math at Caltech. 
</br></br>

My research interests include cryptography, computer security, coding theory, algorithms, and other areas in the foundations of computer science. 

</font>
      </FONT></SPAN></H2>

  <TD vAlign=top width="46%" height=79>

      <P align=center>
		<img border="0" title="EletteBoyle" alt="Elette Boyle" src="JapaneseBreakfast.jpg" width="373" height="285"
align="right"></P></TD></TR>

  <TR>

    <TD width="46%" height=24>&nbsp;</TD></TR></TBODY></TABLE>

<TABLE height=187 cellSpacing=1 cellPadding=8 width="100%" border=0>

  <TBODY>
  
  
  
  
  
  <TR>

    <TD vAlign=top width=92 bgColor=#A0A0A0>

      <H2><FONT color=#000000>Internships and Visists</FONT></H2></TD>

    <TD dir=ltr align=left bgColor=#D0D0D0>

	<ul>

<LI><H2><span
style="font-weight: 400"> </span> Microsoft Research Silicon Valley
</br>
<SPAN style="FONT-WEIGHT: 400">Research Internship, Summer 2011  </SPAN></Li>

<LI><H2><span
style="font-weight: 400"> </span> Weizmann Institute of Science
</br>
<SPAN style="FONT-WEIGHT: 400">Visiting Student, Spring and Summer 2010  </SPAN></Li>

<LI><H2><span
style="font-weight: 400"> </span> US Department of Defense 
</br>
<SPAN style="FONT-WEIGHT: 400">Research Internship, Director's Summer Program, Summer 2007   </SPAN></Li>


<LI><H2><span
style="font-weight: 400"> </span> NASA Jet Propulsion Laboratory 
</br>
<SPAN style="FONT-WEIGHT: 400">Research Internship, Robotic Software Systems Group, Summer 2005
</br>
Mars Science Laboratory (Curiosity Rover) Mission.   </SPAN></Li>

	  </ul>
   </TD></TR>



  
  
  


  <TR>

    <TD vAlign=top width=92 bgColor=#B0B0B0>

      <H2><FONT color=#000000>Publications</FONT></H2></TD>

    <TD dir=ltr align=left bgColor=#D0D0D0>

      <UL>







		<LI><H2><SPAN style="FONT-WEIGHT: 400"> Elette Boyle
	 and Rafael Pass</SPAN><span
style="font-weight: 400"><br> </span>Limits of Extractability Assumptions with Distributional Auxiliary Input 
<br><SPAN
	style="FONT-WEIGHT: 400">Manuscript, 2013.</SPAN><SPAN
style="FONT-WEIGHT: 400"><br> 		[<a
href="javascript:toggle('abstract-ext-assmpt')">Abstract</a>] 		[<a
href="http://eprint.iacr.org/2013/703.pdf">PDF</a>]
</SPAN></H2> 			 <div
class="box" id="abstract-ext-assmpt" style="border-style:solid; border-width:1px;
display: none; padding-left:4px; padding-right:4px; padding-top:1px;
padding-bottom:1px; background-color:#F0F0F0"> 			<h2><span style="font-weight:
400">
Extractability, or "knowledge," assumptions (such as the "knowledge-of-exponent" assumption) have recently gained popularity in the cryptographic community&mdash;leading to the study of primitives such as extractable one-way functions, extractable hash functions, succinct non-interactive arguments of knowledge (SNARKs), and extractable obfuscation, and spurring the development of a wide spectrum of new applications relying on these primitives. For most of these applications, it is required that the extractability assumption holds even in the presence of attackers receiving some auxiliary information that is sampled from some fixed efficiently computable distribution Z.
</br></br>
We show that, assuming the existence of collision-resistant hash functions, there exists a pair of efficient distributions Z, Z'; such that either:
<ul>
<li> extractable one-way functions w.r.t. Z do not exist, or </li>
<li> extractability obfuscations for Turing machines w.r.t. Z do not exist. </li>
</ul>
</br></br> 

A corollary of this result shows that assuming existence of fully homomorphic encryption with decryption in NC1, there exist efficient distributions Z, Z' such that either
<ul>
<li> extractability obfuscations for NC1 w.r.t. Z do not exist, or </li>
<li> SNARKs for NP w.r.t. Z' do not exist. </li>
</ul>
</br></br> 

To achieve our results, we develop a "succinct punctured program" technique, mirroring the powerful "punctured program" technique of Sahai and Waters (ePrint'13), and present several other applications of this new technique.
</span></h2> </div>






		<LI><H2><SPAN style="FONT-WEIGHT: 400"> Elette Boyle,
	 Rafael Pass, and Kai-Min Chung</SPAN><span
style="font-weight: 400"><br> </span>
On Extractability Obfuscation
<br><SPAN
	style="FONT-WEIGHT: 400">To appear: TCC 2014.</SPAN><SPAN
style="FONT-WEIGHT: 400"><br> 		[<a
href="javascript:toggle('abstract-eO')">Abstract</a>] 		[<a
href="http://eprint.iacr.org/2013/650.pdf">PDF</a>]
</SPAN></H2> 			 <div
class="box" id="abstract-eO" style="border-style:solid; border-width:1px;
display: none; padding-left:4px; padding-right:4px; padding-top:1px;
padding-bottom:1px; background-color:#F0F0F0"> 			<h2><span style="font-weight:
400">
We initiate the study of <i>extractability obfuscation</i>, a notion first suggested by Barak et al. (JACM 2012): An extractability obfuscator eO for a class of algorithms M guarantees that if an efficient attacker A can distinguish between obfuscations eO(M_1), eO(M_2) of two algorithms M_1,M_2 \in M, then A can efficiently recover (given M_1 and M_2) an input on which M_1 and M_2 provide different outputs.

<ul>
<li>We rely on the recent candidate virtual black-box obfuscation constructions to provide candidate constructions of extractability obfuscators for NC^1; next, following the blueprint of Garg et~al. (FOCS 2013), we show how to bootstrap the obfuscator for NC^1 to an obfuscator for all non-uniform polynomial-time Turing machines. In contrast to the construction of Garg et al., which relies on indistinguishability obfuscation for NC^1, our construction enables succinctly obfuscating non-uniform <i>Turing machines</i> (as opposed to circuits), without turning running-time into description size.
</li>
<li>We introduce a new notion of <i>functional witness encryption</i>, which enables encrypting a message m with respect to an instance x, language L, and function f, such that anyone (and only those) who holds a witness w for x \in L can compute f(m,w) on the message and particular known witness. We show that functional witness encryption is, in fact, equivalent to extractability obfuscation.
</li>
<li> We demonstrate other applications of extractability extraction, including the first construction of fully (adaptive-message) indistinguishability-secure functional encryption for an unbounded number of key queries and unbounded message spaces.
</li>
<li> We finally relate indistinguishability obfuscation and extractability obfuscation and show special cases when indistinguishability obfuscation can be turned into extractability obfuscation.
</li>
</ul>
</span></h2> </div>






		<LI><H2><SPAN style="FONT-WEIGHT: 400"> Elette Boyle,
	  Shafi Goldwasser, and Ioana Ivan</SPAN><span
style="font-weight: 400"><br> </span>
Functional Signatures and Pseudorandom Functions
<br><SPAN
	style="FONT-WEIGHT: 400">Manuscript, 2013.</SPAN><SPAN
style="FONT-WEIGHT: 400"><br> 		[<a
href="javascript:toggle('abstract-fnalSigs')">Abstract</a>] 		[<a
href="http://eprint.iacr.org/2013/401.pdf">PDF</a>]
</SPAN></H2> 			 <div
class="box" id="abstract-fnalSigs" style="border-style:solid; border-width:1px;
display: none; padding-left:4px; padding-right:4px; padding-top:1px;
padding-bottom:1px; background-color:#F0F0F0"> 			<h2><span style="font-weight:
400">
In this paper, we introduce two new cryptographic primitives: <i>functional digital signatures</i> and <i>functional pseudorandom functions</i>.
</br></br>

In a functional signature scheme, in addition to a master signing key that can be used to sign any message, there are <i>signing keys for a function</i> f, which allow one to sign any message in the range of f. As a special case, this implies the ability to generate keys for predicates P, which allow one to sign any message m, for which P(m) = 1.
</br></br>

We show applications of functional signatures to constructing succinct non-interactive arguments and delegation schemes. We give several general constructions for this primitive based on different computational hardness assumptions, and describe the trade-offs between them in terms of the assumptions they require and the size of the signatures.
</br></br>

In a functional pseudorandom function, in addition to a master secret key that can be used to evaluate the pseudorandom function F on any point in the domain, there are additional <i>secret keys for a function</i> f, which allow one to evaluate F on any y for which there exists an x such that f(x)=y. As a special case, this implies <i>pseudorandom functions with selective access</i>, where one can delegate the ability to evaluate the pseudorandom function on inputs y for which a predicate P(y)=1 holds. We define and provide a sample construction of a functional pseudorandom function family for prefix-fixing functions.
</span></h2> </div>




		<LI><H2><SPAN style="FONT-WEIGHT: 400"> Elette Boyle,
	  Sanjam Garg, Abhishek Jain, Yael Tauman Kalai, and Amit Sahai
	 </SPAN><span
style="font-weight: 400"><br> </span>
Secure Computation Against Adaptive Auxiliary Information
<br><SPAN
	style="FONT-WEIGHT: 400">CRYPTO 2013 - International Conference on Cryptology.</SPAN><SPAN
style="FONT-WEIGHT: 400"><br> 		[<a
href="javascript:toggle('abstract-WLR-MPC')">Abstract</a>] 		[<a
href="http://link.springer.com/chapter/10.1007%2F978-3-642-40041-4_18">PDF</a>]
</SPAN></H2> 			 <div
class="box" id="abstract-WLR-MPC" style="border-style:solid; border-width:1px;
display: none; padding-left:4px; padding-right:4px; padding-top:1px;
padding-bottom:1px; background-color:#F0F0F0"> 			<h2><span style="font-weight:
400">
We study the problem of secure two-party and multiparty computation (MPC) in a setting where a cheating polynomial-time adversary can corrupt an arbitrary subset of parties and, in addition, learn arbitrary auxiliary information on the entire states of all honest parties (including their inputs and random coins), in an adaptive manner, throughout the protocol execution. We formalize a definition of multiparty computation secure against adaptive auxiliary information (AAI-MPC), that intuitively guarantees that such an adversary learns no more than the function output and the adaptive auxiliary information. In particular, if the auxiliary information contains only partial, "noisy," or computationally invertible information on secret inputs, then only such information should be revealed.
</br></br> 

We construct a universally composable AAI two-party and multiparty computation protocol that realizes any (efficiently computable) functionality against malicious adversaries in the common reference string model, based on the linear assumption over bilinear groups and the <i>n</i>-th residuosity assumption. Apart from theoretical interest, our result has interesting applications to the regime of leakage-resilient cryptography.
</br></br>

At the heart of our construction is a new two-round oblivious transfer protocol secure against malicious adversaries who may receive adaptive auxiliary information. This may be of independent interest.
</span></h2> </div>




		<LI><H2><SPAN style="FONT-WEIGHT: 400"> Elette Boyle,
	Shafi Goldwasser, and Stefano Tessaro
	 </SPAN><span
style="font-weight: 400"><br> </span>
Communication Locality in Secure Multi-party Computation: 
<br/>How to Run Sublinear Algorithms in a Distributed Setting
<br><SPAN
	style="FONT-WEIGHT: 400">TCC 2013 - Theory of Cryptography Conference.</SPAN><SPAN
style="FONT-WEIGHT: 400"><br> 		[<a
href="javascript:toggle('abstract-sl-mpc')">Abstract</a>] 		[<a
href="http://web.mit.edu/eboyle/www/MPC-Locality-TCC13.pdf">PDF</a>]
</SPAN></H2> 			 <div
class="box" id="abstract-sl-mpc" style="border-style:solid; border-width:1px;
display: none; padding-left:4px; padding-right:4px; padding-top:1px;
padding-bottom:1px; background-color:#F0F0F0"> 			<h2><span style="font-weight:
400">
We devise multi-party computation protocols for general secure function evaluation with the property that each party is only required to communicate with a small number of dynamically chosen parties. More explicitly, starting with n parties connected via a complete and synchronous network, our protocol requires each party to send messages to (and process messages from) at most polylog(n) other parties using polylog(n) rounds. It achieves secure computation of any polynomial-time computable randomized function f under cryptographicassumptions, and tolerates up to (1/3 - \eps)·n statically scheduled Byzantine faults.
<br/><br/>
We then focus on the particularly interesting setting in which the function to be computed is a sublinear algorithm: An evaluation of f depends on the inputs of at most q = o(n) of the parties, where the identity of these parties can be chosen randomly and possibly adaptively. Typically, q = polylog(n). While the sublinear query complexity of f makes it pos- sible in principle to dramatically reduce the communication complexity of our general protocol, the challenge is to achieve this while maintaining security: in particular, while keeping the identities of the selected inputs completely hidden. We solve this challenge, and we provide a protocol for securely computing such sublinear f that runs in polylog(n) + O(q) rounds, has each party communicating with at most q · polylog(n) other parties, and supports message sizes polylog(n) · (l + n), where l is the parties' input size.
</br></br>
Our optimized protocols rely on a multi-signature scheme, fully homomorphic encryption (FHE), and simulation-sound adaptive NIZK arguments. However, we remark that multi-signatures and FHE are used to obtain our bounds on message size and round complexity. Assuming only standard digital signatures and public-key encryption, one can still obtain the property that each party only communicates with polylog(n) other parties. We emphasize that the scheduling of faults can depend on the initial PKI setup of digital signatures and the NIZK parameters
</span></h2> </div>




		<LI><H2><SPAN style="FONT-WEIGHT: 400"> Elette Boyle,
	Shafi Goldwasser, Abhishek Jain, and Yael Tauman Kalai
	 </SPAN><span
style="font-weight: 400"><br> </span>
Multi-Party Computation Secure Against Continual Memory Leakage
<br><SPAN
	style="FONT-WEIGHT: 400">STOC 2012 - ACM Symposium on Theory of Computing.</SPAN><SPAN
style="FONT-WEIGHT: 400"><br> 		[<a
href="javascript:toggle('abstract-LR-MPC')">Abstract</a>] 		[<a
href="http://web.mit.edu/eboyle/www/LR-MPC-STOC12.pdf">PDF</a>]
</SPAN></H2> 			 <div
class="box" id="abstract-LR-MPC" style="border-style:solid; border-width:1px;
display: none; padding-left:4px; padding-right:4px; padding-top:1px;
padding-bottom:1px; background-color:#F0F0F0"> 			<h2><span style="font-weight:
400">
We construct a multiparty computation (MPC) protocol that is secure even if a malicious adversary, in addition to corrupting 1-\eps fraction of all parties for an arbitrarily small constant \eps > 0, can leak information about the secret state of each honest party. This leakage can be continuous for an unbounded number of executions of the MPC protocol, computing different functions on the same or different set of inputs. We assume a (necessary) "leak-free" preprocessing stage.
</br></br>
We emphasize that we achieve leakage resilience without weakening the security guarantee of classical MPC. Namely, an adversary who is given leakage on honest parties' states, is guaranteed to learn nothing beyond the input and output values of corrupted parties. This is in contrast with previous works on leakage in the multi-party protocol setting, which weaken the security notion, and only guarantee that a protocol which leaks l bits about the parties' secret states, yields at most l bits of leakage on the parties' private inputs. For some functions, such as voting, such leakage can be detrimental.
</br></br>

Our result relies on standard cryptographic assumptions, and our security parameter is polynomially related to the number of parties.
</span></h2> </div>





		<LI><H2><SPAN style="FONT-WEIGHT: 400"> Elette Boyle,
	Shafi Goldwasser, and Yael Tauman Kalai
	 </SPAN><span
style="font-weight: 400"><br> </span>
Leakage-Resilient Coin Tossing
<br><SPAN
	style="FONT-WEIGHT: 400">DISC 2011 - The International Symposium on Distributed Computing.
	</br> <i>Invited to Distributed Computing.</i></SPAN><SPAN
style="FONT-WEIGHT: 400"><br> 		[<a
href="javascript:toggle('abstract-LR-coin')">Abstract</a>] 		[<a
href="http://eprint.iacr.org/2011/291">PDF</a>]
</SPAN></H2> 			 <div
class="box" id="abstract-LR-coin" style="border-style:solid; border-width:1px;
display: none; padding-left:4px; padding-right:4px; padding-top:1px;
padding-bottom:1px; background-color:#F0F0F0"> 			<h2><span style="font-weight:
400">
The ability to collectively toss a common coin among n parties in the presence of faults is an important primitive in the arsenal of randomized distributed protocols. In the case of dishonest majority, it was shown to be impossible to achieve less than 1/r bias in O(r) rounds (Cleve STOC '86). In the case of honest majority, in contrast, unconditionally secure O(1)-round protocols for generating common perfectly <i>unbiased</i> coins follow from general completeness theorems on multi-party secure protocols in the perfectly secure channels model (e.g., BGW, CCD STOC '88).
</br></br>

However, in the multi-party protocols with faulty minority, parties need to generate and hold local secret values which are assumed to be <i>perfectly hidden</i> from malicious parties: an assumption which is crucial to proving the resulting common coin is unbiased. This assumption unfortunately does not seem to hold in practice, as attackers can launch side-channel attacks on the local state of honest parties and leak information on their secrets.
</br></br>

In this work, we present an O(1)-round protocol for collectively generating an unbiased common coin, in the presence of leakage on the local state of the honest parties. We tolerate t <= (1/3 - \eps) n computationally-unbounded Byzantine faults and in addition a \Omega(1)-fraction leakage on each (honest) party's secret state. Our results hold in the memory leakage model (of Akavia, Goldwasser, Vaikuntanathan '08) adapted to the distributed setting.
</br></br>

Another contribution of our work is a tool we use to achieve collective coin flipping -- <i>leakage-resilient verifiable secret sharing</i>. Informally, this is a variant of ordinary VSS in which secrecy guarantees are maintained even if information is leaked on individual shares of the secret.

</span></h2> </div>





<LI><H2><SPAN style="FONT-WEIGHT: 400"> Elette Boyle,
	Gil Segev, and Daniel Wichs
	 </SPAN><span
style="font-weight: 400"><br> </span>
Fully Leakage-Resilient Signatures
<br><SPAN
	style="FONT-WEIGHT: 400">Advances in Crytology - EUROCRYPT 2011.
	</br> <i>Invited to Journal of Cryptology.</i></SPAN><SPAN
style="FONT-WEIGHT: 400"><br> 		[<a
href="javascript:toggle('abstract-FLR-sig')">Abstract</a>] 		[<a
href="http://eprint.iacr.org/2010/488">PDF</a>]
</SPAN></H2> 			 <div
class="box" id="abstract-FLR-sig" style="border-style:solid; border-width:1px;
display: none; padding-left:4px; padding-right:4px; padding-top:1px;
padding-bottom:1px; background-color:#F0F0F0"> 			<h2><span style="font-weight:
400">
A signature scheme is <i>fully leakage resilient</i> (Katz and Vaikuntanathan, ASIACRYPT '09) if it is existentially unforgeable under an adaptive chosen-message attack even in a setting where an adversary may obtain bounded (yet arbitrary) leakage information on <i>all intermediate values that are used throughout the lifetime of the system</i>. This is a strong and meaningful notion of security that captures a significantly wide range of side-channel attacks.
</br></br>

One of the main challenges in constructing fully leakage-resilient signature schemes is dealing with leakage that may depend on the random bits used by the signing algorithm, and constructions of such schemes are known only in the random-oracle model. Moreover, even in the random-oracle model, known schemes are only resilient to leakage of less than half the length of their signing key.
</br></br>

In this paper we construct the first fully leakage-resilient signature schemes without random oracles. We present a scheme that is resilient to any leakage of length (1-o(1))L bits, where L is the length of the signing key. Our approach relies on generic cryptographic primitives, and at the same time admits rather efficient instantiations based on specific number-theoretic assumptions. In addition, we show that our approach extends to the continual-leakage model, recently introduced by Dodis, Haralambiev, Lopez-Alt and Wichs (FOCS '10), and by Brakerski, Tauman Kalai, Katz and Vaikuntanathan (FOCS '10). In this model the signing key is allowed to be refreshed, while its corresponding verification key remains fixed, and the amount of leakage is assumed to be bounded only in between any two successive key refreshes.
</span></h2> </div>





<LI><H2><SPAN style="FONT-WEIGHT: 400"> Elette Boyle
	and Federico Echenique
	 </SPAN><span
style="font-weight: 400"><br> </span>
Sequential Entry in Many-to-One Matching Markets
<br><SPAN
	style="FONT-WEIGHT: 400">Social Choice and Welfare, Springer, Vol 33(1), June 2009: pp 87-99. </SPAN><SPAN
style="FONT-WEIGHT: 400"><br> 		[<a
href="javascript:toggle('abstract-matching')">Abstract</a>] 		[<a
href="http://web.mit.edu/eboyle/www/Sequential-Entry-SCW09.pdf">PDF</a>]
</SPAN></H2> 			 <div
class="box" id="abstract-matching" style="border-style:solid; border-width:1px;
display: none; padding-left:4px; padding-right:4px; padding-top:1px;
padding-bottom:1px; background-color:#F0F0F0"> 			<h2><span style="font-weight:
400">
We study sequential bargaining in many-to-one matching markets. We show that there is an advantage to entering late in the market, and that the last agent to enter the market will receive his or her best partner in a stable matching, extending the results of Blum and Rothblum (J Econ Theory 103(2):429-443, 2002) and Cechlárová (Randomized matching mechanism revisited. Mimeo, Safarik University, 2002) for the marriage model. We also discuss the relation between sequential bargaining and a possible alternative formulation based on the NTU Shapley value.
</span></h2> </div>





<LI><H2><SPAN style="FONT-WEIGHT: 400"> Elette Boyle
	and Robert McEliece
	 </SPAN><span
style="font-weight: 400"><br> </span>
Asymptotic Weight Enumerators of Randomly Punctured, Expurgated, and Shortened Code Ensembles 
<br><SPAN
	style="FONT-WEIGHT: 400">46th Annual Allerton Conference on Communication, Control, and Computing, 2008. </SPAN><SPAN
style="FONT-WEIGHT: 400"><br> 		[<a
href="javascript:toggle('abstract-codes')">Abstract</a>] 		[<a
href="http://web.mit.edu/eboyle/www/Altered-Codes-Allerton08.pdf">PDF</a>]
</SPAN></H2> 			 <div
class="box" id="abstract-codes" style="border-style:solid; border-width:1px;
display: none; padding-left:4px; padding-right:4px; padding-top:1px;
padding-bottom:1px; background-color:#F0F0F0"> 			<h2><span style="font-weight:
400">
In this paper, we examine the effect of random puncturing, expurgating, and shortening on the asymptotic weight enumerator of certain linear code ensembles. We begin by discussing the actions of the three alteration methods on individual codes. We derive expressions for the average resulting code weight enumerator under each alteration. We then extend these results to the spectral shape of linear code ensembles whose original spectral shape is known, and demonstrate our findings on two specific code ensembles: the Shannon ensemble and the regular (j, k) Gallager ensemble.
</span></h2> </div>


<LI><H2><SPAN style="FONT-WEIGHT: 400"> Elette Boyle
	 </SPAN><span
style="font-weight: 400"><br> </span>
Navigation on Mars: Validation of the Mars Science Laboratory Rover Hazard Avoidance Algorithm
<br><SPAN
	style="FONT-WEIGHT: 400">Caltech Undergraduate Research Journal Vol 5, 2006: pp 21-25. </SPAN><SPAN
style="FONT-WEIGHT: 400"><br> 		

</SPAN></H2> 			 <div
class="box" id="abstract-MSL" style="border-style:solid; border-width:1px;
display: none; padding-left:4px; padding-right:4px; padding-top:1px;
padding-bottom:1px; background-color:#F0F0F0"> 			<h2><span style="font-weight:
400">
The Mars Science Laboratory (MSL) is a long-range, long-durationroving laboratory planned for launch in 2009. While humans can issue commands to the rover on Mars, the delay in transmission means navigation functions requiring immediate action, such as recognizing hazards and locating pathways of safety, must be controlled autonomously. The autonomous navigation software currently used in Mars rovers is designed for use in terrains with minimal inclines and few obstacles. However, for MSL, NASA is developing a more advanced version of the Mars Exploration Rover (MER) GESTALT hazard detection and avoidance software. Ensuring that GESTALT functions correctly and effectively is a crucial task, since a malfunction could result in failure of the entire mission. Before use on Mars, GESTALT performance must be verified in a cross-section of potential terrains, including regions with rocks, craters, and slopes. The purpose of the summer research project was to test GESTALT in terrains of a range of rock hazard densities.
</span></h2> </div>



</LI></UL></TD></TR>













 <TR>

    <TD vAlign=top width=92 bgColor=#A0A0A0>

      <H2><FONT color=#000000>Program Committees</FONT></H2></TD>

    <TD dir=ltr align=left bgColor=#D0D0D0>

	<ul>

 	  <li>Conference on Security and Cryptography for Networks (SCN) 2014.</li>
	  </ul>
   </TD></TR>
   
   
   
   
   
   </TBODY></TABLE>


</BODY>
</HTML>









